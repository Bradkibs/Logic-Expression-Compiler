#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <libgen.h>
#include "C_Components/ast.h"
#include "C_Components/symbol_table.h"
#include "C_Components/semantic_analyzer.h"
#include "C_Components/multi_statement.h"
#include "C_Components/llvm_codegen.h"

// Forward declarations for parser functions (generated by bison)
extern int yyparse();
extern FILE* yyin;

// The root of the AST - declared as extern since it's defined elsewhere
extern Node* parsed_expression;

// Function to initialize a multi-statement AST
MultiStatementAST* init_multi_statement_ast() {
    MultiStatementAST* ast = (MultiStatementAST*)malloc(sizeof(MultiStatementAST));
    if (!ast) return NULL;
    
    ast->capacity = 10;  // Start with capacity for 10 statements
    ast->count = 0;
    ast->statements = (Node**)malloc(ast->capacity * sizeof(Node*));
    
    if (!ast->statements) {
        free(ast);
        return NULL;
    }
    
    return ast;
}

// Function to add a statement to the multi-statement AST
void add_statement(MultiStatementAST* ast, Node* statement) {
    if (!ast || !statement) return;
    
    // Resize if needed
    if (ast->count >= ast->capacity) {
        ast->capacity *= 2;
        Node** new_statements = (Node**)realloc(ast->statements, ast->capacity * sizeof(Node*));
        if (!new_statements) return;
        ast->statements = new_statements;
    }
    
    // Add the statement
    ast->statements[ast->count++] = statement;
}

// Function to free a multi-statement AST
void free_multi_statement_ast(MultiStatementAST* ast) {
    if (!ast) return;
    
    // Free each statement
    for (int i = 0; i < ast->count; i++) {
        free_ast(ast->statements[i]);
    }
    
    free(ast->statements);
    free(ast);
}

// Function to print usage information
void print_usage() {
    printf("Usage: lec_compiler_llvm <input_file> [output_file]\n");
    printf("If output_file is not specified, the executable will be named 'output'\n");
}

// Function to get the base name of a file (without extension)
char* get_base_name(const char* file_path) {
    // Find the last path separator
    const char* last_slash = strrchr(file_path, '/');
    const char* file_name = last_slash ? last_slash + 1 : file_path;
    
    // Find the last dot (extension separator)
    const char* last_dot = strrchr(file_name, '.');
    
    // Calculate length of the base name
    size_t base_len = last_dot ? (size_t)(last_dot - file_name) : strlen(file_name);
    
    // Allocate memory for the base name
    char* base_name = (char*)malloc(base_len + 1);
    if (!base_name) {
        return NULL;
    }
    
    // Copy the base name
    strncpy(base_name, file_name, base_len);
    base_name[base_len] = '\0';
    
    return base_name;
}

// Read the entire file into a buffer
char* read_file_contents(const char* input_file) {
    FILE* file = fopen(input_file, "r");
    if (!file) {
        fprintf(stderr, "Error: Could not open input file '%s'\n", input_file);
        return NULL;
    }
    
    // Get file size
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    rewind(file);
    
    // Allocate buffer with extra space for null terminator
    char* buffer = (char*)malloc(file_size + 1);
    if (!buffer) {
        fprintf(stderr, "Error: Failed to allocate memory for file contents\n");
        fclose(file);
        return NULL;
    }
    
    // Read the file into the buffer
    size_t read_size = fread(buffer, 1, file_size, file);
    buffer[read_size] = '\0';  // Null-terminate the buffer
    
    fclose(file);
    return buffer;
}

// Pre-process assignments to build the symbol table
void process_assignments(const char* file_contents, SymbolTable* symbol_table) {
    printf("Pre-processing assignments...\n");
    
    // Make a copy of the file contents
    char* buffer = strdup(file_contents);
    if (!buffer) return;
    
    // Process each line
    char* line = strtok(buffer, "\n");
    while (line) {
        // Skip empty lines
        if (strlen(line) > 0) {
            // Check if this is a simple assignment (format: VAR = VALUE)
            // We need to be more strict to avoid misinterpreting expressions like A -> B
            if (strstr(line, "=") && !strstr(line, "=>") && !strstr(line, "-->") && 
                !strstr(line, "<->") && !strstr(line, "<==>") && !strstr(line, "IMPLIES") && 
                !strstr(line, "DOUBLEIMPLIES") && !strstr(line, "IFF")) {
                // Simple direct parsing for TRUE/FALSE assignments
                char var_name[MAX_SYMBOL_NAME_LENGTH] = {0};
                char var_value[20] = {0};
                
                if (sscanf(line, "%49s = %19s", var_name, var_value) == 2) {
                    int value = 0;
                    
                    // Check for TRUE/FALSE directly
                    if (strcmp(var_value, "TRUE") == 0) {
                        value = 1;
                    } else if (strcmp(var_value, "FALSE") == 0) {
                        value = 0;
                    }
                    
                    // Add to symbol table
                    add_or_update_symbol(symbol_table, var_name, value);
                    printf("Added variable '%s' with value %d to symbol table\n", var_name, value);
                    line = strtok(NULL, "\n");
                    continue;
                }
                
                // If direct parsing fails, use the parser
                FILE* temp = tmpfile();
                if (!temp) {
                    fprintf(stderr, "Error: Failed to create temporary file\n");
                    line = strtok(NULL, "\n");
                    continue;
                }
                
                fputs(line, temp);
                rewind(temp);
                
                yyin = temp;
                parsed_expression = NULL;
                int parse_result = yyparse();
                fclose(temp);
                
                if (parse_result == 0 && parsed_expression) {
                    // If it's an assignment, extract the variable name and value
                    if (parsed_expression->type == NODE_ASSIGN && parsed_expression->name) {
                        int value = 0;
                        if (parsed_expression->right) {
                            if (parsed_expression->right->type == NODE_BOOL) {
                                value = parsed_expression->right->bool_val;
                            } else if (parsed_expression->right->type == NODE_VAR) {
                                if (parsed_expression->right->name) {
                                    if (strcmp(parsed_expression->right->name, "TRUE") == 0) {
                                        value = 1;
                                    } else if (strcmp(parsed_expression->right->name, "FALSE") == 0) {
                                        value = 0;
                                    }
                                }
                            }
                        }
                        
                        // Add the variable to the symbol table
                        add_or_update_symbol(symbol_table, parsed_expression->name, value);
                        printf("Added variable '%s' with value %d to symbol table\n", 
                               parsed_expression->name, value);
                    }
                    
                    free_ast(parsed_expression);
                    parsed_expression = NULL;
                }
            }
        }
        
        line = strtok(NULL, "\n");
    }
    
    free(buffer);
}

// Function to read a file line by line and parse each statement
MultiStatementAST* parse_file_by_lines(const char* input_file, SymbolTable* symbol_table) {
    MultiStatementAST* ast = init_multi_statement_ast();
    if (!ast) return NULL;
    
    // First read the entire file
    char* file_contents = read_file_contents(input_file);
    if (!file_contents) {
        free_multi_statement_ast(ast);
        return NULL;
    }
    
    // Pre-process assignments to build the symbol table
    process_assignments(file_contents, symbol_table);
    
    // Now parse each line with the complete symbol table
    char* buffer = strdup(file_contents);
    if (!buffer) {
        free(file_contents);
        free_multi_statement_ast(ast);
        return NULL;
    }
    
    // Process each line
    char* line = strtok(buffer, "\n");
    int line_num = 0;
    
    while (line) {
        line_num++;
        
        // Skip empty lines
        if (strlen(line) > 0) {
            // Parse the line
            FILE* temp = tmpfile();
            if (!temp) {
                fprintf(stderr, "Error: Failed to create temporary file\n");
                line = strtok(NULL, "\n");
                continue;
            }
            
            fputs(line, temp);
            rewind(temp);
            
            yyin = temp;
            parsed_expression = NULL;
            int parse_result = yyparse();
            fclose(temp);
            
            if (parse_result != 0 || !parsed_expression) {
                fprintf(stderr, "Warning: Failed to parse line %d: %s\n", line_num, line);
                line = strtok(NULL, "\n");
                continue;
            }
            
            // Add the statement to our multi-statement AST
            add_statement(ast, parsed_expression);
            parsed_expression = NULL;  // Reset for next parse
        }
        
        line = strtok(NULL, "\n");
    }
    
    free(buffer);
    free(file_contents);
    
    return ast;
}

// Function to compile a logical expression file
int compile_file(const char* input_file, const char* output_file) {
    // Initialize the symbol table
    SymbolTable* symbol_table = init_symbol_table();
    if (!symbol_table) {
        fprintf(stderr, "Error: Failed to initialize symbol table\n");
        return 1;
    }
    
    // Parse the input file line by line
    printf("Parsing input file '%s'...\n", input_file);
    MultiStatementAST* multi_ast = parse_file_by_lines(input_file, symbol_table);
    if (!multi_ast || multi_ast->count == 0) {
        fprintf(stderr, "Error: No AST was generated\n");
        free_symbol_table(symbol_table);
        if (multi_ast) free_multi_statement_ast(multi_ast);
        return 1;
    }
    
    // Print the symbol table for debugging
    printf("Symbol table contains %d symbols:\n", symbol_table->size);
    for (int i = 0; i < symbol_table->size; i++) {
        printf("  %s = %s\n", symbol_table->symbols[i].name, 
               symbol_table->symbols[i].value ? "TRUE" : "FALSE");
    }
    
    // Generate LLVM IR
    printf("Generating LLVM IR...\n");
    
    // Pass the entire multi-statement AST to the LLVM backend
    LLVMCodegenResult ir_result = generate_llvm_ir(multi_ast, symbol_table, output_file);
    if (ir_result.error_code != LLVM_CODEGEN_OK) {
        fprintf(stderr, "LLVM code generation error: %s\n", ir_result.error_message);
        free_llvm_codegen_result(&ir_result);
        free_multi_statement_ast(multi_ast);
        free_symbol_table(symbol_table);
        return 1;
    }
    
    // Compile and link the generated IR
    printf("Compiling and linking...\n");
    LLVMCodegenResult compile_result = compile_and_link_ir(ir_result.output_file, output_file);
    if (compile_result.error_code != LLVM_CODEGEN_OK) {
        fprintf(stderr, "Compilation error: %s\n", compile_result.error_message);
        free_llvm_codegen_result(&ir_result);
        free_llvm_codegen_result(&compile_result);
        free_multi_statement_ast(multi_ast);
        free_symbol_table(symbol_table);
        return 1;
    }
    
    // Clean up
    printf("Compilation successful. Executable created: %s\n", compile_result.output_file);
    free_llvm_codegen_result(&ir_result);
    free_llvm_codegen_result(&compile_result);
    free_multi_statement_ast(multi_ast);
    free_symbol_table(symbol_table);
    
    return 0;
}

int main(int argc, char** argv) {
    // Check arguments
    if (argc < 2 || argc > 3) {
        print_usage();
        return 1;
    }
    
    const char* input_file = argv[1];
    
    // Determine output file name
    char* output_file;
    if (argc == 3) {
        output_file = strdup(argv[2]);
    } else {
        // Use "output" as the default output file name
        output_file = strdup("output");
    }
    
    // Compile the file
    int result = compile_file(input_file, output_file);
    
    // Clean up
    free(output_file);
    
    return result;
}
