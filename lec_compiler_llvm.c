#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <libgen.h>
#include <unistd.h>  // For mkdtemp
#include "C_Unlinked_Components/ast.h"
#include "C_Unlinked_Components/symbol_table.h"
#include "C_Unlinked_Components/semantic_analyzer.h"
#include "C_Unlinked_Components/multi_statement.h"
#include "C_Unlinked_Components/llvm_codegen.h"

// Forward declarations for parser functions (generated by bison)
extern int yyparse();
extern FILE* yyin;

// The root of the AST - declared as extern since it's defined elsewhere
extern Node* parsed_expression;

// Function to initialize a multi-statement AST
MultiStatementAST* init_multi_statement_ast() {
    MultiStatementAST* ast = (MultiStatementAST*)malloc(sizeof(MultiStatementAST));
    if (!ast) return NULL;
    
    ast->capacity = 10;  // Start with capacity for 10 statements
    ast->count = 0;
    ast->statements = (Node**)malloc(ast->capacity * sizeof(Node*));
    
    if (!ast->statements) {
        free(ast);
        return NULL;
    }
    
    return ast;
}

// Function to add a statement to the multi-statement AST
void add_statement(MultiStatementAST* ast, Node* statement) {
    if (!ast || !statement) return;
    
    // Resize if needed
    if (ast->count >= ast->capacity) {
        ast->capacity *= 2;
        Node** new_statements = (Node**)realloc(ast->statements, ast->capacity * sizeof(Node*));
        if (!new_statements) return;
        ast->statements = new_statements;
    }
    
    // Add the statement
    ast->statements[ast->count++] = statement;
}

// Function to free a multi-statement AST
void free_multi_statement_ast(MultiStatementAST* ast) {
    if (!ast) return;
    
    // Free each statement
    for (int i = 0; i < ast->count; i++) {
        free_ast(ast->statements[i]);
    }
    
    free(ast->statements);
    free(ast);
}

// Function to print usage information
void print_usage() {
    printf("Usage: lec_compiler_llvm <input_file> [-oN]\n");
    printf("  -oN  Set optimization level (0-3, default: 0)\n");
    printf("Example: lec_compiler_llvm input.lec -o2\n");
}

// Function to get the base name of a file (without extension)
char* get_base_name(const char* file_path) {
    // Find the last path separator
    const char* last_slash = strrchr(file_path, '/');
    const char* file_name = last_slash ? last_slash + 1 : file_path;
    
    // Find the last dot (extension separator)
    const char* last_dot = strrchr(file_name, '.');
    
    // Calculate length of the base name
    size_t base_len = last_dot ? (size_t)(last_dot - file_name) : strlen(file_name);
    
    // Allocate memory for the base name
    char* base_name = (char*)malloc(base_len + 1);
    if (!base_name) {
        return NULL;
    }
    
    // Copy the base name
    strncpy(base_name, file_name, base_len);
    base_name[base_len] = '\0';
    
    return base_name;
}

// Read the entire file into a buffer
char* read_file_contents(const char* input_file) {
    FILE* file = fopen(input_file, "r");
    if (!file) {
        fprintf(stderr, "Error: Could not open input file '%s'\n", input_file);
        return NULL;
    }
    
    // Get file size
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    rewind(file);
    
    // Allocate buffer with extra space for null terminator
    char* buffer = (char*)malloc(file_size + 1);
    if (!buffer) {
        fprintf(stderr, "Error: Failed to allocate memory for file contents\n");
        fclose(file);
        return NULL;
    }
    
    // Read the file into the buffer
    size_t read_size = fread(buffer, 1, file_size, file);
    buffer[read_size] = '\0';  // Null-terminate the buffer
    
    fclose(file);
    return buffer;
}

// Pre-process assignments to build the symbol table
void process_assignments(const char* file_contents, SymbolTable* symbol_table) {
    printf("Pre-processing assignments...\n");
    
    // Make a copy of the file contents
    char* buffer = strdup(file_contents);
    if (!buffer) return;
    
    // Process each line
    char* line = strtok(buffer, "\n");
    while (line) {
        // Skip empty lines
        if (strlen(line) > 0) {
            // Check if this is a simple assignment (format: VAR = VALUE)
            // We need to be more strict to avoid misinterpreting expressions like A -> B
            if (strstr(line, "=") && !strstr(line, "=>") && !strstr(line, "-->") && 
                !strstr(line, "<->") && !strstr(line, "<==>") && !strstr(line, "IMPLIES") && 
                !strstr(line, "DOUBLEIMPLIES") && !strstr(line, "IFF")) {
                // Simple direct parsing for TRUE/FALSE assignments
                char var_name[MAX_SYMBOL_NAME_LENGTH] = {0};
                char var_value[20] = {0};
                
                if (sscanf(line, "%49s = %19s", var_name, var_value) == 2) {
                    int value = 0;
                    
                    // Check for TRUE/FALSE directly
                    if (strcmp(var_value, "TRUE") == 0) {
                        value = 1;
                    } else if (strcmp(var_value, "FALSE") == 0) {
                        value = 0;
                    }
                    
                    // Add to symbol table
                    add_or_update_symbol(symbol_table, var_name, value);
                    printf("Added variable '%s' with value %d to symbol table\n", var_name, value);
                    line = strtok(NULL, "\n");
                    continue;
                }
                
                // If direct parsing fails, use the parser
                FILE* temp = tmpfile();
                if (!temp) {
                    fprintf(stderr, "Error: Failed to create temporary file\n");
                    line = strtok(NULL, "\n");
                    continue;
                }
                
                fputs(line, temp);
                rewind(temp);
                
                yyin = temp;
                parsed_expression = NULL;
                int parse_result = yyparse();
                fclose(temp);
                
                if (parse_result == 0 && parsed_expression) {
                    // If it's an assignment, extract the variable name and value
                    if (parsed_expression->type == NODE_ASSIGN && parsed_expression->name) {
                        int value = 0;
                        if (parsed_expression->right) {
                            if (parsed_expression->right->type == NODE_BOOL) {
                                value = parsed_expression->right->bool_val;
                            } else if (parsed_expression->right->type == NODE_VAR) {
                                if (parsed_expression->right->name) {
                                    if (strcmp(parsed_expression->right->name, "TRUE") == 0) {
                                        value = 1;
                                    } else if (strcmp(parsed_expression->right->name, "FALSE") == 0) {
                                        value = 0;
                                    }
                                }
                            }
                        }
                        
                        // Add the variable to the symbol table
                        add_or_update_symbol(symbol_table, parsed_expression->name, value);
                        printf("Added variable '%s' with value %d to symbol table\n", 
                               parsed_expression->name, value);
                    }
                    
                    free_ast(parsed_expression);
                    parsed_expression = NULL;
                }
            }
        }
        
        line = strtok(NULL, "\n");
    }
    
    free(buffer);
}

// Function to read a file line by line and parse each statement
MultiStatementAST* parse_file_by_lines(const char* input_file, SymbolTable* symbol_table) {
    MultiStatementAST* ast = init_multi_statement_ast();
    if (!ast) return NULL;
    
    // First read the entire file
    char* file_contents = read_file_contents(input_file);
    if (!file_contents) {
        free_multi_statement_ast(ast);
        return NULL;
    }
    
    // Pre-process assignments to build the symbol table
    process_assignments(file_contents, symbol_table);
    
    // Now parse each line with the complete symbol table
    char* buffer = strdup(file_contents);
    if (!buffer) {
        free(file_contents);
        free_multi_statement_ast(ast);
        return NULL;
    }
    
    // Process each line
    char* line = strtok(buffer, "\n");
    int line_num = 0;
    
    while (line) {
        line_num++;
        
        // Skip empty lines
        if (strlen(line) > 0) {
            // Parse the line
            FILE* temp = tmpfile();
            if (!temp) {
                fprintf(stderr, "Error: Failed to create temporary file\n");
                line = strtok(NULL, "\n");
                continue;
            }
            
            fputs(line, temp);
            rewind(temp);
            
            yyin = temp;
            parsed_expression = NULL;
            int parse_result = yyparse();
            fclose(temp);
            
            if (parse_result != 0 || !parsed_expression) {
                fprintf(stderr, "Warning: Failed to parse line %d: %s\n", line_num, line);
                line = strtok(NULL, "\n");
                continue;
            }
            
            // Add the statement to our multi-statement AST
            add_statement(ast, parsed_expression);
            parsed_expression = NULL;  // Reset for next parse
        }
        
        line = strtok(NULL, "\n");
    }
    
    free(buffer);
    free(file_contents);
    
    return ast;
}

// Global variable for optimization level
int optimization_level = 0;

// Function to compile a logical expression file
int compile_file(const char* input_file, const char* output_file) {
    // Initialize the symbol table
    SymbolTable* symbol_table = init_symbol_table();
    if (!symbol_table) {
        fprintf(stderr, "Error: Failed to initialize symbol table\n");
        return 1;
    }
    
    // Parse the input file line by line
    printf("Parsing input file '%s'...\n", input_file);
    MultiStatementAST* multi_ast = parse_file_by_lines(input_file, symbol_table);
    if (!multi_ast || multi_ast->count == 0) {
        fprintf(stderr, "Error: No AST was generated\n");
        free_symbol_table(symbol_table);
        if (multi_ast) free_multi_statement_ast(multi_ast);
        return 1;
    }
    
    // Print the symbol table for debugging
    printf("Symbol table contains %d symbols:\n", symbol_table->size);
    for (int i = 0; i < symbol_table->size; i++) {
        printf("  %s = %s\n", symbol_table->symbols[i].name, 
               symbol_table->symbols[i].value ? "TRUE" : "FALSE");
    }
    
    // Perform semantic analysis on each expression in the AST
    for (int i = 0; i < multi_ast->count; i++) {
        Node* expr = multi_ast->statements[i];
        if (!expr) continue;
        
        // Skip assignments since they've already been processed
        if (expr->type == NODE_ASSIGN) continue;
        
        SemanticAnalysisResult semantic_result = perform_semantic_analysis(expr, symbol_table);
        if (semantic_result.error_code != SEMANTIC_OK) {
            fprintf(stderr, "Semantic error in expression: %s\n", semantic_result.error_message);
            if (semantic_result.error_message) free(semantic_result.error_message);
            free_multi_statement_ast(multi_ast);
            free_symbol_table(symbol_table);
            return 1;
        }
    }
    
    // Generate LLVM IR with optimizations
    printf("Generating LLVM IR with optimization level -O%d...\n", optimization_level);
    
    // Create a temporary directory for intermediate files
    char temp_dir[] = "/tmp/lec_XXXXXX";
    if (!mkdtemp(temp_dir)) {
        perror("Failed to create temporary directory");
        free_multi_statement_ast(multi_ast);
        free_symbol_table(symbol_table);
        return 1;
    }
    
    // Generate LLVM IR with the specified optimization level
    LLVMCodegenResult ir_result = generate_llvm_ir(multi_ast, symbol_table, output_file, optimization_level);
    if (ir_result.error_code != LLVM_CODEGEN_OK) {
        fprintf(stderr, "LLVM code generation error: %s\n", 
                ir_result.error_message ? ir_result.error_message : "Unknown error");
        free_llvm_codegen_result(&ir_result);
        free_multi_statement_ast(multi_ast);
        free_symbol_table(symbol_table);
        
        // Clean up temp directory
        char cmd[2048];
        snprintf(cmd, sizeof(cmd), "rm -rf %s", temp_dir);
        system(cmd);
        return 1;
    }
    
    // Create a temporary IR file in the temp directory
    char temp_ir_filename[2048];
    snprintf(temp_ir_filename, sizeof(temp_ir_filename), "%s/temp.ll", temp_dir);
    
    // Save the IR to the temporary file first
    LLVMCodegenResult temp_save = save_llvm_ir(ir_result.module, temp_ir_filename);
    if (temp_save.error_code != LLVM_CODEGEN_OK) {
        fprintf(stderr, "Warning: Failed to save temporary IR file: %s\n", 
               temp_save.error_message ? temp_save.error_message : "Unknown error");
        free_llvm_codegen_result(&temp_save);
        // Continue anyway as this is not a critical error
    }
    
    // Create the output IR filename (same as output file but with .ll extension)
    char ir_filename[2048];
    snprintf(ir_filename, sizeof(ir_filename), "%s.ll", output_file);
    
    // Save the IR to the final location
    LLVMCodegenResult save_result = save_llvm_ir(ir_result.module, ir_filename);
    if (save_result.error_code != LLVM_CODEGEN_OK) {
        fprintf(stderr, "Failed to save LLVM IR: %s\n", 
                save_result.error_message ? save_result.error_message : "Unknown error");
        free_llvm_codegen_result(&ir_result);
        free_llvm_codegen_result(&save_result);
        free_multi_statement_ast(multi_ast);
        free_symbol_table(symbol_table);
        // Clean up temp directory
        char cmd[2048];
        snprintf(cmd, sizeof(cmd), "rm -rf %s", temp_dir);
        system(cmd);
        return 1;
    }
    
    // Compile and link the generated IR
    printf("Compiling and linking LLVM IR...\n");
    LLVMCodegenResult compile_result = compile_and_link_ir(ir_filename, output_file);
    
    // Clean up intermediate files
    char cleanup_cmd[4096];
    snprintf(cleanup_cmd, sizeof(cleanup_cmd), "rm -rf %s", temp_dir);
    system(cleanup_cmd);
    
    if (compile_result.error_code != LLVM_CODEGEN_OK) {
        fprintf(stderr, "Compilation error: %s\n", 
                compile_result.error_message ? compile_result.error_message : "Unknown error");
        free_llvm_codegen_result(&ir_result);
        free_llvm_codegen_result(&save_result);
        free_llvm_codegen_result(&compile_result);
        free_multi_statement_ast(multi_ast);
        free_symbol_table(symbol_table);
        return 1;
    }
    
    // Clean up
    printf("Compilation successful. Executable created: %s\n", output_file);
    printf("LLVM IR was saved to: %s\n", ir_filename);
    free_llvm_codegen_result(&ir_result);
    free_llvm_codegen_result(&save_result);
    free_llvm_codegen_result(&compile_result);
    free_multi_statement_ast(multi_ast);
    free_symbol_table(symbol_table);
    
    return 0;
}

int main(int argc, char** argv) {
    // Check arguments
    if (argc < 2) {
        print_usage();
        return 1;
    }
    
    const char* input_file = NULL;
    char* output_file = strdup("output"); // Default output file name
    
    // Parse command line arguments
    for (int i = 1; i < argc; i++) {
        if (strncmp(argv[i], "-o", 2) == 0) {
            // Handle optimization level
            if (strlen(argv[i]) > 2) {
                // Format: -oN (e.g., -o2)
                optimization_level = atoi(argv[i] + 2);
                if (optimization_level < 0 || optimization_level > 3) {
                    fprintf(stderr, "Error: Optimization level must be between 0 and 3\n");
                    free(output_file);
                    return 1;
                }
            }
        } else if (argv[i][0] != '-') {
            // This is the input file
            if (input_file == NULL) {
                input_file = argv[i];
            } else {
                // Second non-option argument is treated as output file (for backward compatibility)
                free(output_file);
                output_file = strdup(argv[i]);
            }
        } else {
            fprintf(stderr, "Error: Unknown option %s\n", argv[i]);
            print_usage();
            free(output_file);
            return 1;
        }
    }
    
    if (input_file == NULL) {
        fprintf(stderr, "Error: No input file specified\n");
        print_usage();
        free(output_file);
        return 1;
    }
    
    printf("Compiling %s with optimization level -O%d\n", input_file, optimization_level);
    
    // Compile the file
    int result = compile_file(input_file, output_file);
    
    // Clean up
    free(output_file);
    
    return result;
}
